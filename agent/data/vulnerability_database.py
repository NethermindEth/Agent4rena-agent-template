"""
Database of known Solidity vulnerabilities based on historical hacks.
"""
from typing import Dict, List, Optional
from pydantic import BaseModel


class VulnerabilityPattern(BaseModel):
    """Model for vulnerability patterns to detect in code."""
    pattern: str
    description: str
    context_lines: int = 3  # Number of lines to check for context


class Vulnerability(BaseModel):
    """Model for a vulnerability in the database."""
    id: str
    name: str
    description: str
    cvss_score: float
    cvss_vector: str
    detection_patterns: List[VulnerabilityPattern]
    historical_examples: List[str]
    remediation_example: str
    references: List[str]


# Database of known vulnerabilities
VULNERABILITY_DATABASE: Dict[str, Vulnerability] = {
    "reentrancy": Vulnerability(
        id="SWC-107",
        name="Reentrancy",
        description="A vulnerability where an external contract call can call back into the calling contract before the first execution is complete.",
        cvss_score=8.6,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N",
        detection_patterns=[
            VulnerabilityPattern(
                pattern=r"\.call{value:",
                description="Use of low-level call with value"
            ),
            VulnerabilityPattern(
                pattern=r"\.send\(|\.transfer\(",
                description="Use of send or transfer"
            )
        ],
        historical_examples=[
            "The DAO Hack (2016): Attackers exploited a reentrancy vulnerability to drain 3.6M ETH.",
            "Uniswap/Lendf.me (2020): Reentrancy attack on ERC-777 tokens led to $25M loss."
        ],
        remediation_example="""
// Vulnerable code
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount);
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
    balances[msg.sender] -= amount;
}

// Fixed code
function withdraw(uint256 amount) public {
    require(balances[msg.sender] >= amount);
    balances[msg.sender] -= amount;
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success);
}
        """,
        references=[
            "https://swcregistry.io/docs/SWC-107",
            "https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/"
        ]
    ),
    
    "access_control": Vulnerability(
        id="SWC-105",
        name="Unprotected Access Control",
        description="Critical functions that lack proper access controls, allowing unauthorized users to execute them.",
        cvss_score=7.5,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
        detection_patterns=[
            VulnerabilityPattern(
                pattern=r"function\s+\w+\s*\([^)]*\)\s*public(?!\s+view|\s+pure)",
                description="Public function without access modifiers"
            ),
            VulnerabilityPattern(
                pattern=r"function\s+withdraw|transfer|mint|burn",
                description="Critical function names that might need access control"
            )
        ],
        historical_examples=[
            "Parity Multi-Sig Wallet (2017): Lack of access control allowed an attacker to take ownership and freeze $300M worth of ETH.",
            "Poly Network Hack (2021): Exploited access control issues to steal $600M across multiple chains."
        ],
        remediation_example="""
// Vulnerable code
function transferOwnership(address newOwner) public {
    owner = newOwner;
}

// Fixed code
function transferOwnership(address newOwner) public {
    require(msg.sender == owner, "Not authorized");
    owner = newOwner;
}
        """,
        references=[
            "https://swcregistry.io/docs/SWC-105",
            "https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/access-control/"
        ]
    ),
    
    "flash_loan_attack": Vulnerability(
        id="CUSTOM-001",
        name="Flash Loan Attack Vulnerability",
        description="Vulnerability to price manipulation via flash loans, allowing attackers to exploit price oracles or lending protocols.",
        cvss_score=8.2,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:H",
        detection_patterns=[
            VulnerabilityPattern(
                pattern=r"oracle|price feed|getPrice|fetchPrice",
                description="Use of price oracles that might be manipulated"
            ),
            VulnerabilityPattern(
                pattern=r"uniswap|sushiswap|pancakeswap",
                description="References to DEXes that might be used for price manipulation"
            )
        ],
        historical_examples=[
            "bZx Attack (2020): Flash loan attack resulted in $350,000 loss.",
            "Harvest Finance (2020): Flash loan attack led to $33.8M loss through price manipulation.",
            "Cream Finance (2021): Flash loan attack resulted in $130M loss."
        ],
        remediation_example="""
// Vulnerable code
function getAssetPrice(address asset) public view returns (uint256) {
    return dexPair.getReserves(); // Directly using DEX state for pricing
}

// Fixed code
function getAssetPrice(address asset) public view returns (uint256) {
    // Use time-weighted average price (TWAP)
    return twapOracle.consultTwap(asset, amountIn, tokenOut);
    // Or use multiple price sources
    uint256 price1 = oracle1.getPrice(asset);
    uint256 price2 = oracle2.getPrice(asset);
    uint256 price3 = oracle3.getPrice(asset);
    return median(price1, price2, price3);
}
        """,
        references=[
            "https://medium.com/immunefi/the-ultimate-guide-to-flash-loans-and-flash-loan-attacks-2c12b6e3290b",
            "https://blog.chain.link/flash-loans-and-the-importance-of-tamper-proof-oracles/"
        ]
    ),
    
    # Add more vulnerabilities based on historical hacks
    "integer_overflow": Vulnerability(
        id="SWC-101",
        name="Integer Overflow and Underflow",
        description="Arithmetic operations reaching the maximum or minimum size of the type, causing the value to wrap around.",
        cvss_score=7.5,
        cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:H",
        detection_patterns=[
            VulnerabilityPattern(
                pattern=r"\+\+|\+=|[^SafeMath]\.\w+\s*\+",
                description="Increment operations without SafeMath"
            ),
            VulnerabilityPattern(
                pattern=r"--|-=|[^SafeMath]\.\w+\s*-",
                description="Decrement operations without SafeMath"
            )
        ],
        historical_examples=[
            "Beauty Chain (BEC) Token (2018): Integer overflow bug allowed attackers to generate massive amounts of tokens.",
            "PoWHC (2018): Integer overflow in balance calculations led to loss of funds."
        ],
        remediation_example="""
// Vulnerable code (pre-Solidity 0.8.0)
function transfer(address to, uint256 amount) public {
    balances[msg.sender] -= amount;
    balances[to] += amount;
}

// Fixed code (pre-Solidity 0.8.0)
function transfer(address to, uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    balances[msg.sender] = balances[msg.sender].sub(amount);
    balances[to] = balances[to].add(amount);
}

// Fixed code (Solidity 0.8.0+)
// Overflow/underflow checks are built into the compiler
function transfer(address to, uint256 amount) public {
    require(balances[msg.sender] >= amount, "Insufficient balance");
    unchecked { // Only use unchecked when you're sure overflow/underflow won't happen
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
        """,
        references=[
            "https://swcregistry.io/docs/SWC-101",
            "https://consensys.github.io/smart-contract-best-practices/attacks/arithmetic/"
        ]
    ),
    
    "front_running": Vulnerability(
        id="SWC-114",
        name="Front-Running Vulnerability",
        description="Transaction ordering dependence that can be exploited by miners or other users to gain advantage.",
        cvss_score=5.9,
        cvss_vector="CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:H/A:N",
        detection_patterns=[
            VulnerabilityPattern(
                pattern=r"block\.timestamp|now",
                description="Use of block timestamp for critical logic"
            ),
            VulnerabilityPattern(
                pattern=r"reveal|commit|password|secret",
                description="Patterns suggesting commit-reveal schemes"
            )
        ],
        historical_examples=[
            "Bancor (2018): Front-running vulnerability in their exchange mechanism.",
            "EtherDelta (2017): Front-running attacks on decentralized exchanges."
        ],
        remediation_example="""
// Vulnerable code
function claimPrize(string memory password) public {
    require(keccak256(abi.encodePacked(password)) == passwordHash);
    msg.sender.transfer(prize);
}

// Fixed code - Commit-reveal scheme
// Step 1: User submits hash of (password + user address + random nonce)
function commitSolution(bytes32 solutionHash) public {
    require(commitments[msg.sender] == 0, "Already committed");
    commitments[msg.sender] = solutionHash;
    commitmentTimes[msg.sender] = block.timestamp;
}

// Step 2: After reveal period, user reveals solution
function revealSolution(string memory password, uint256 nonce) public {
    bytes32 solutionHash = keccak256(abi.encodePacked(password, msg.sender, nonce));
    require(commitments[msg.sender] == solutionHash, "Invalid solution");
    require(block.timestamp >= commitmentTimes[msg.sender] + 24 hours, "Too early");
    require(keccak256(abi.encodePacked(password)) == passwordHash, "Wrong password");
    
    msg.sender.transfer(prize);
}
        """,
        references=[
            "https://swcregistry.io/docs/SWC-114",
            "https://consensys.github.io/smart-contract-best-practices/attacks/frontrunning/"
        ]
    )
}


def get_vulnerability(vuln_id: str) -> Optional[Vulnerability]:
    """Get a vulnerability by ID."""
    return VULNERABILITY_DATABASE.get(vuln_id)


def get_all_vulnerabilities() -> List[Vulnerability]:
    """Get all vulnerabilities in the database."""
    return list(VULNERABILITY_DATABASE.values())


def get_vulnerability_by_name(name: str) -> Optional[Vulnerability]:
    """Get a vulnerability by name."""
    for vuln in VULNERABILITY_DATABASE.values():
        if vuln.name.lower() == name.lower():
            return vuln
    return None